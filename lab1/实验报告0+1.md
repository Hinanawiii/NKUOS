# 实验0.5

1. **环境准备**：
   - 确保在Linux环境中安装了QEMU和GDB，并编译了RISC-V的内核（ucore）。
   - 使用`make`命令生成可执行的内核镜像文件（`ucore.img`）。

2. **启动QEMU**：
   - 使用以下命令启动QEMU，加载内核镜像：
     ```bash
     make debug
     ```
   - 这个命令会启用GDB调试模式并等待GDB的连接。

3. **连接GDB**：
   - 在另一个终端中，使用以下命令启动GDB并连接到QEMU：
     ```bash
     make gdb
   - 这将使GDB连接到QEMU的调试端口（localhost:1234）。

4. **执行到指定地址**：
   - 在GDB中使用命令`jump 0x80200000`跳转到内核入口点，开始执行内核代码。

5. **查看指令**：
   - 使用命令`x/10xw 0x80200000`查看0x80200000地址及其后10个字的内容，输出如下：
     ```
     0x80200000 <kern_entry>:        0x00003117
     0x80200004:                     0x00010113
     0x80200008:                     0x3517a009
     0x8020000c:                     0x05130000
     0x80200010 <kern_init+6>:       0x3617ffe5
     0x80200014:                     0x06130000
     0x80200018:                     0x1141ff66
     0x8020001c:                     0x8e094581
     0x80200020 <kern_init+22>:      0x00efe406
     0x80200024:                     0x05974940
     ```

### 指令分析

1. **0x80200000 (kern_entry)**:
   - 指令：`0x00003117`
   - 功能：这是一条指令，用于设置一个基地址（通常是返回地址）。

2. **0x80200004**:
   - 指令：`0x00010113`
   - 功能：加载立即数到寄存器中。

3. **0x80200008**:
   - 指令：`0x3517a009`
   - 功能：执行存储操作，将寄存器的值存储到内存。

4. **0x8020000c**:
   - 指令：`0x05130000`
   - 功能：配置中断处理或者某些状态寄存器。

5. **0x80200010 (kern_init)**:
   - 指令：`0x3617ffe5`
   - 功能：进入内核初始化，可能是在进入一个循环或初始化状态。

### 结论

通过本次实验，熟悉了如何使用QEMU和GDB进行调试，并了解了RISC-V加电后第一条指令的执行过程。这些指令负责了内核的初始化及基本配置，成功跳转到了`kern_init`函数，并开始执行进一步的初始化过程。



# 实验1

## 练习1

### 1. 指令 `la sp, bootstacktop`
- **操作**: 这条指令使用 `la`（load address）指令将 `bootstacktop` 的地址加载到栈指针 `sp` 中。
- **目的**: 
  - **初始化栈指针**: `sp` 是用于指向当前栈顶的寄存器。通过将其设置为 `bootstacktop` 的地址，内核为后续的函数调用和局部变量分配提供了一个有效的栈空间。这是内核启动过程中的关键步骤，因为许多后续操作（如初始化各个子系统）需要使用栈。
  - **栈空间分配**: `bootstack` 是内核的栈区域，定义在 `.data` 段中，分配了足够的空间（`KSTACKSIZE`）用于处理内核的操作。

### 2. 指令 `tail kern_init`
- **操作**: `tail` 是一个特殊的指令，它会跳转到 `kern_init` 函数并替换当前函数的返回地址为 `kern_init` 的地址。这意味着，`kern_init` 将成为当前函数的尾部调用（tail call），没有返回的开销。
- **目的**:
  - **启动内核初始化**: `kern_init` 函数负责执行内核的初始化任务，如设置内存管理、初始化进程管理等。`tail` 指令确保在执行完 `kern_init` 后，程序不会回到调用者，避免不必要的栈帧创建。
  - **优化性能**: 由于 `tail` 调用优化了栈的使用，减少了函数调用的开销，因此在性能要求较高的内核初始化阶段尤为重要。

## 练习2

### 定时器中断处理流程

1. **时钟中断触发**: 系统每当到达设定的定时器频率时，触发时钟中断。

2. **进入中断处理程序**: CPU 保存当前执行状态，并转入中断处理程序。在 `trap` 函数中，根据中断类型判断是否为时钟中断。

3. **处理时钟中断**:
   - 调用 `clock_set_next_event()` 设置下次中断。
   - 增加 `ticks` 计数器。
   - 判断是否达到了 100 次中断，若是则调用 `print_ticks()`。
   - 检查已打印次数，若达到 10 次则调用 `sbi_shutdown()` 关机。

4. **返回执行**: 完成所有处理后，恢复之前保存的执行状态，返回到中断发生前的位置，继续执行主程序。

## CHALLENEGE1 

### 中断异常处理流程

1. **异常的产生**: 当处理器检测到异常（如时钟中断、系统调用等），会触发一个中断信号，CPU 保存当前执行状态，并跳转到中断处理程序（如 `__alltraps`）。

2. **保存上下文**: 在 `__alltraps` 中，首先调用 `SAVE_ALL` 宏保存当前寄存器状态和其他必要信息到栈中，以便后续恢复。

3. **处理异常**: 通过 `jal trap` 跳转到具体的异常处理函数，处理相关的异常逻辑。

4. **恢复上下文**: 异常处理完成后，调用 `RESTORE_ALL` 宏从栈中恢复之前保存的寄存器状态。

5. **返回执行**: 最后，通过 `sret` 指令返回到异常发生前的位置，继续执行主程序。

### 关键指令解析

- **`mov a0, sp` 的目的**: 此指令将当前栈指针 `sp` 的值移动到寄存器 `a0` 中，以便在后续的异常处理函数中使用。`a0` 通常用于传递参数，在这里它可以作为一个指向当前上下文的指针。

- **`SAVE_ALL` 中寄存器**: 该宏中寄存器的保存位置是通过 `sp`（栈指针）偏移来确定的。每个寄存器依次存储到栈中的特定偏移量，确保在恢复时能够正确恢复到原来的位置。

- **需要保存所有寄存器**: 对于任何中断，`__alltraps` 中都需要保存所有寄存器。原因是中断处理可能会在任何时间发生，当前执行的上下文必须被完整保存，以便在处理完成后能够恢复到准确的状态。如果不保存所有寄存器，可能会导致程序在返回时状态不一致，从而引发错误或崩溃。

## CHALLENEGE2

### 汇编代码分析

1. **指令解析**
   - **`csrw sscratch, sp`**: 此指令将当前栈指针 `sp` 的值写入到 `sscratch` 寄存器中，目的是在处理异常时保存当前的栈指针状态，以便后续的恢复操作。
   - **`csrrw s0, sscratch, x0`**: 这条指令将 `sscratch` 寄存器的值写入 `s0` 寄存器，并将 `sscratch` 设为 0。这样做的目的是为了在发生递归异常时，能够识别该异常来源于内核。

2. **保存与恢复**
   - **`SAVE_ALL` 中保存的 CSR**: `SAVE_ALL` 宏保存了多个 CSR 寄存器（如 `stval`、`scause` 等），但在 `RESTORE_ALL` 中却没有还原它们。这是因为这些寄存器用于异常处理的状态管理，并不需要在每次返回时恢复。它们的保存意义在于在处理完异常后，可以根据需要对异常进行后续处理或记录。

3. **存储的意义**
   - 保存这些 CSR 寄存器的意义在于提供了对异常的上下文信息，使得在异常处理程序中能够正确判断异常的来源和状态。在处理完成后，可能会根据这些信息决定接下来的操作，而不是简单地恢复状态。