### 练习

对实验报告的要求：

- 基于markdown格式来完成，以文本方式为主
- 填写各个基本练习中要求完成的报告内容
- 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别
- 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
- 列出你认为OS原理中很重要，但在实验中没有对应上的知识点

#### 练习0：填写已有实验

本实验依赖实验1/2。请把你做的实验1/2的代码填入本实验中代码中有“LAB1”,“LAB2”的注释相应部分。

##### <span style="color:red">本次实验给出的内容很完善，根本没有这个必要</span>

#### 练习1：理解基于FIFO的页面替换算法（思考题）

描述FIFO页面置换算法下，一个页面从被换入到被换出的过程中，会经过代码里哪些函数/宏的处理（或者说，需要调用哪些函数/宏），并用简单的一两句话描述每个函数在过程中做了什么？（为了方便同学们完成练习，所以实际上我们的项目代码和实验指导的还是略有不同，例如我们将FIFO页面置换算法头文件的大部分代码放在了`kern/mm/swap_fifo.c`文件中，这点请同学们注意）

- 至少正确指出10个不同的函数分别做了什么？如果少于10个将酌情给分。我们认为只要函数原型不同，就算两个不同的函数。要求指出对执行过程有实际影响,删去后会导致输出结果不同的函数（例如assert）而不是cprintf这样的函数。如果你选择的函数不能完整地体现”从换入到换出“的过程，比如10个函数都是页面换入的时候调用的，或者解释功能的时候只解释了这10个函数在页面换入时的功能，那么也会扣除一定的分数

#### 换入换出的过程

- 0.当发生缺页异常时，出现异常的地址会传入 `do_pgfault`函数进行缺页的处理。此时使用 `get_pte` 函数获取/创建对应虚拟地址映射过程中页表和页表项

- 1.若页表项为0，表示还未分配过这个也，使用`pgdir_alloc_page`分配物理页并使用`page_insert`建立映射，此外，在`alloc_pages`中增加循环，以备在页数不够时用`swap_out`函数将超出的页面换出，此时会调用页面置换管理器的`swap_out_victim`按照对应的策略换出页面，并且使用 `swapfs_write`将页面内容写入文件系统中。

- 2.若页表项不为0，则说明这个地址对应的页之前被换出过的，此时则需要使用`swap_in`函数将页面内容读入对应的页面（此时也使用了`swapfs_read`），然后使用`page_insert`建立映射，之后再使用`swap_map_swappable` 调用不同策略的`map_swappable`进行维护

#### 每个函数做了什么

总体的过程如上文所述，下文主要介绍FIFO中这些函数的作用

1. **`do_pgfault`**  
   该函数是整个缺页处理流程的起始点。它通过调用 `get_pte` 获取对应页面的页表项，从而确定页面是需要创建（分配）还是需要从磁盘加载（换入）。

2. **`find_vma`**  
   该函数用于找到包含触发缺页异常的虚拟地址的虚拟内存区域（VMA）。在此过程中，`find_vma` 还会更新相关的 VMA 信息。

3. **`get_pte`**  
   根据触发缺页异常的虚拟地址，`get_pte` 函数查找对应的页表项。如果某一层的页表项不存在，它将为其分配一个新的 4KiB 页面，以存储该层的映射关系。

4. **`swap_in`**  
   `swap_in` 函数负责从磁盘（存储介质）读取页面内容，并将其载入内存中。具体来说，它根据页表项中的 `swap_entry_t`，从硬盘中加载页面数据到内存中。

5. **`swapfs_write`**  
   该函数会调用 `ide_write_secs`，后者用于模拟向 IDE 设备（如硬盘）写入特定扇区的数据。其主要任务是将页面内容写回硬盘。

6. **`alloc_page` / `alloc_pages`**  
   `alloc_page` 是 `alloc_pages` 的宏实现，主要用于分配一个页面。如果分配失败，`alloc_page` 会调用 `swap_out` 来换出指定数量的页面，以腾出空间。

7. **`page_insert`**  
   `page_insert` 函数负责将虚拟地址与新分配的页面的物理地址建立映射关系，并更新页表。

8. **`swap_map_swappable`**  
   在 FIFO 页面置换算法中，`swap_map_swappable` 会直接调用 `_fifo_map_swappable`，将新加入的页面添加到 FIFO 队列的头部，从而保证页面的先进先出（FIFO）替换顺序。

9. **`swap_out`**  
   `swap_out` 函数负责将指定数量的页面从内存中换出，并将其写回硬盘，释放内存空间供新页面使用。

10. **`swapfs_read`**  
    该函数会调用 `ide_write_secs`，后者模拟从 IDE 设备（如硬盘）读取特定扇区的数据。其主要任务是从存储设备读取页面内容并加载到内存中。

11. **`sm->swap_out_victim()`**  
    在 FIFO 页面置换算法中，`sm->swap_out_victim()` 会调用 `_fifo_swap_out_victim` 函数。该函数从 FIFO 队列中选择最早进入内存（即最先进入队列的页面）作为需要被换出的页面，执行页面换出操作。

12. **`free_page`**  
    该函数负责释放被换出的页面对应的物理内存，允许内存重新分配。当页面被换出到硬盘或交换区后，物理内存会被标记为可用，以供新的页面分配。

13. **`tlb_invalidate`**  
    在页面换出之后，`tlb_invalidate` 函数会刷新 TLB（翻译后备缓冲区）。这一步骤是为了防止旧的地址映射仍然存在于 TLB 中，从而导致后续的地址访问错误。


#### 练习2：深入理解不同分页模式的工作原理（思考题）

get_pte()函数（位于`kern/mm/pmm.c`）用于在页表中查找或创建页表项，从而实现对指定线性地址对应的物理页的访问和映射操作。这在操作系统中的分页机制下，是实现虚拟内存与物理内存之间映射关系非常重要的内容。

- get_pte()函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像。
- 目前get_pte()函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？

##### 为什么如此相像？

RISC-V中目前共有四种分⻚模式Sv32，Sv39，Sv48，Sv57。其中Sv32使用了二级⻚表，Sv39使用了三级⻚表，Sv48和Sv57则是使用了四级和五级⻚表。在我们的ucore实验中使用的是Sv39模式，⻚表被分为了：PDX1、PDX0和PTX

这段代码的主要目的是处理不同分页模式下的页表查找。在 RISC-V 的分页机制中，Sv32 使用二级页表，而 Sv39 使用三级页表。在这两种模式下，`get_pte` 函数的行为非常相似，都是通过一系列的地址转换操作，从虚拟地址追踪到物理地址。在 Sv39 模式下，查找过程更为复杂，因为它需要通过多级页表（PDX1、PDE_ADDR 等）逐步找到目标页表项的位置。由于两种模式的查找过程相似，主要的差异在于层级的深度。具体而言，`get_pte` 在 Sv39 模式下会先通过 `PDX1` 查找页表，再使用 `pgdir` 查找对应的页表项，从而最终获取虚拟地址映射到物理地址的页表项。这种多级查找的过程，虽然在不同分页模式下层级不同，但整体逻辑和操作步骤非常相似，因此可以认为这两个代码段的执行流程高度一致。

##### 关于查找和分配的功能

个人认为，`get_pte`将页表项的查找和分配合并在一起的写法是有改进空间的，虽然ucore中需要实现sv39的分页机制，这种写法能够实现功能且能够增强代码的复用，减少可能出现的错误。但是同时意味着可扩展性较差和一些分配后问题，比如分配失败时函数需要返回页表指针，这时已经假设了分配一定成功，代码的维护难度也增加了

下面是一些可能的改进方案

- 把两个功能拆成两个单独的函数，并且分配不同的输入参数和返回值，这样在每一步出现问题都可以适用该步的解决方案，比如查询返回NULL而分配返回错误码 

- 也可以将某一集的页表代码独立成模块等

#### 练习3：给未被映射的地址映射上物理页（需要编程）

补充完成do_pgfault（mm/vmm.c）函数，给未被映射的地址映射上物理页。设置访问权限 的时候需要参考页面所在 VMA 的权限，同时需要注意映射物理页时需要操作内存控制 结构所指定的页表，而不是内核的页表。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：

- 请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。
- 如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？
- 数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？

##### 设计实现过程

1. **查找 VMA**：首先通过 `find_vma` 函数查找包含该地址的 VMA。如果找不到对应的 VMA，或者地址不在有效范围内，则返回错误。
  
2. **检查权限**：根据 VMA 的权限标志（`VM_WRITE`）确定该页是否可以写入，并为页表设置适当的权限。设置 `PTE_U` 表示用户可访问，`PTE_W` 表示可写权限。

3. **获取或创建页表项（PTE）**：通过 `get_pte` 函数获取当前页的页表项，如果页表项不存在则创建一个新的页表并分配物理内存。此时会调用 `pgdir_alloc_page` 来为页表分配新的页。

4. **处理缺页（如果页表项已存在）**：如果页表项已存在但指向的是交换条目（swap entry），则需要从磁盘加载该页面。使用 `swap_in` 函数将磁盘中的数据加载到内存页中，并使用 `page_insert` 建立虚拟地址与物理地址的映射，确保逻辑地址正确地映射到物理内存。

5. **处理可交换页面**：如果页面是可交换的，调用 `swap_map_swappable` 将页面标记为可交换，并设置页面的访问情况。

6. **错误处理**：如果在任何步骤中遇到错误，例如内存不足或者页表创建失败，则跳转到错误处理逻辑。

##### 页目录项（Page Directory Entry）和页表项（Page Table Entry）在 `ucore` 实现页替换算法中的潜在用处

页目录项（PDE）和页表项（PTE）包含了虚拟内存到物理内存的映射关系。在 `ucore` 的页替换算法中，PDE 和 PTE 通过指向物理页面的地址来管理内存。PTE 包含有关页面的访问权限、页面是否被换出（swap entry）等信息。在发生缺页异常时，PTE 的状态会决定是否需要从磁盘加载页面，或是否需要进行页面换出。

##### 如果ucore的缺⻚服务例程在执行过程中访问内存，出现了⻚访问异常，请问硬件要做哪些事情？

- 当硬件检测到页访问异常时，会触发一个页故障异常。硬件将会：
     1. 将异常地址存储在 `stval` 寄存器中。而异常指令地址存入`sepc`寄存器中
     2. 设置错误代码，包含访问权限、操作类型（读/写）以及异常的上下文（用户模式/内核模式）。
     3. 控制权将转交给内核的异常处理程序（`do_pgfault`），由内核根据虚拟地址、错误代码和页目录信息处理页缺失。


##### 数据结构Page与⻚表的关系：

是的，`Page` 的每一项与页表中的PDE和PTE是有对应关系的。每个 `Page` 代表一个物理页面，它的映射关系通过页表项来建立。在页表项中，物理页的地址会被记录，而在 `Page` 结构中，物理页的具体数据和管理信息会被存储。页目录项和页表项共同管理虚拟内存到物理内存的映射关系。需要注意的是`pages`中的页并不一定会全部使用

#### 练习4：补充完成Clock页替换算法（需要编程）

通过之前的练习，相信大家对FIFO的页面替换算法有了更深入的了解，现在请在我们给出的框架上，填写代码，实现 Clock页替换算法（mm/swap_clock.c）。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：

- 比较Clock页替换算法和FIFO算法的不同。

##### 实现过程

- 1.初始化 `pra_list_head`：在 `clock_init_mm` 函数中，我初始化了一个链表（pra_list_head），该链表用于记录所有可替换的页面。`curr_pt`r` 指针指向链表头，表示当前页面替换的候选位置。

- 2.管理可交换页面：通过 `_clock_map_swappable` 函数，我将新的页面链接到 `pra_list_head`链表的末尾，并设置页面的访问位为 1，表示该页面是最近访问的。

- 3.页面替换：在 `_clock_swap_out_victim` 函数中，我实现了页面替换的逻辑。该函数遍历链表，检查每个页面的访问位。如果某个页面的访问位为 0（表示未使用），则选择它进行替换；如果访问位为 1，则将访问位清零，并将指针移动到下一个页面，继续检查其他页面。

- 4.页面访问管理：为了支持 Clock 算法的访问位管理，我在每次访问页面时更新页面的访问位。这样可以确保页面替换的决策基于页面的实际使用情况，而不是简单的 FIFO 顺序。

- 5.内存管理和页面交换：在实现过程中，我还需要确保页面的物理内存与虚拟内存之间的映射正确，并在页面被替换时进行必要的内存交换（从磁盘加载数据到内存）。

##### 比较Clock算法和FIFO算法

- 优点：
    - 比 FIFO 更智能，能够考虑页面的使用情况，避免替换那些刚被使用的页面。
    - 比 FIFO 更节省内存和时间开销，减少了对页面顺序的维护。
    - 在实际应用中，相比 FIFO，它可以避免 Belady's Anomaly，通常提供更好的性能。
- 缺点：
    - 实现复杂度比 FIFO 略高，需要使用指针和访问位来管理页面。
    - 如果没有正确设置访问位，它可能会导致不必要的页面替换。

#### 练习5：阅读代码和实现手册，理解页表映射方式相关知识（思考题）

如果我们采用”一个大页“ 的页表映射方式，相比分级页表，有什么好处、优势，有什么坏处、风险？

##### 好处和优势

1. **简化操作**：
   - 采用一个大页的页表映射方式，系统可以将操作系统的页表结构减少为单一的映射，这样就避免了多级页表的查找开销。当系统需要访问大范围的内存时，能够通过大页一次性映射大块内存，简化了地址转换的过程。
   
2. **减少 TLB Miss**：
   - 使用一个大页的方式时，每个页表项对应更大的虚拟内存区域，这减少了每次内存访问时 TLB（Translation Lookaside Buffer）的查找次数。由于一个大页能够映射更大的内存区域，当该大页被加载到 TLB 中时，访问该页内的多个虚拟地址就可以命中 TLB，减少了 TLB miss 的次数，从而提高了内存访问的效率。

3. **提高内存访问效率**：
   - 由于访问一个大页能覆盖更广的内存空间，因此减少了页表项的数量和页表的层次结构，降低了页面访问的复杂度。这对提高程序的执行速度和整体性能有重要作用，尤其是在处理大数据量时更为明显。

##### 坏处和风险

1. **内存浪费**：
   - 使用大页的一个主要问题是内存可能被浪费。如果程序的内存访问没有很好的局部性，或者大页的分配并未完全利用，那么就会有较大的内存碎片问题。虽然大页减少了页表项的数量，但在大页的分配和管理上可能会导致较高的内存浪费，尤其是在内存访问模式不规律时。

2. **不适合频繁小页访问**：
   - 如果应用程序的访问模式主要集中在小范围的内存访问上，那么使用一个大页可能并不合适。因为大页虽然可以减少 TLB miss，但如果只有少部分内存被访问，而其他部分未被使用，那么大页就会造成不必要的内存占用，增加内存的需求。

3. **增加页表管理复杂度**：
   - 当页表页的大小非常大时，整个页表的管理变得复杂，尤其是对于系统需要进行页面交换（swap）时。页表项过大可能导致交换的效率降低，需要进行更多的交换操作来管理大页的内存区域，这对于交换管理器的负担是一个挑战。

4. **系统兼容性和硬件支持问题**：
   - 现代硬件对大页的支持虽然逐渐增强（例如，支持 2MB 或 1GB 的大页），但并非所有硬件都支持大页，或者支持的范围较小。对于不支持大页的硬件，采用大页可能无法发挥其优势，甚至可能导致系统性能的下降。

5. **增加的迁移开销**：
   - 对于需要频繁迁移进程或内存的系统来说，采用大页会导致内存管理的复杂性增加。大页的迁移和管理开销较大，可能会影响整体的系统效率，特别是在内存资源紧张的情况下。

#### 扩展练习 Challenge：实现不考虑实现开销和效率的LRU页替换算法（需要编程）

challenge部分不是必做部分，不过在正确最后会酌情加分。需写出有详细的设计、分析和测试的实验报告。完成出色的可获得适当加分。
