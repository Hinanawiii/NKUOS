## 练习

对实验报告的要求：

 - 基于markdown格式来完成，以文本方式为主
 - 填写各个基本练习中要求完成的报告内容
 - 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别
 - 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
 - 列出你认为OS原理中很重要，但在实验中没有对应上的知识点

## 练习0：填写已有实验

本实验依赖实验1/2。请把你做的实验1/2的代码填入本实验中代码中有“LAB1”,“LAB2”的注释相应部分。

## 练习1：理解基于FIFO的页面替换算法（思考题）

**1. 初始化阶段**

#### **函数：`swap_init`**

- 功能: 初始化页面置换的核心模块。
  - 调用 `swapfs_init` 初始化交换文件系统。
  - 设置页面置换算法管理器（如 `FIFO` 或 `CLOCK`，默认为 CLOCK 算法）。
  - 验证环境是否支持页面置换（如 `max_swap_offset` 范围）。
  - 调用 `check_swap` 验证页面置换算法的正确性。

#### **函数：`swap_init_mm`**

- 功能: 初始化每个 mm_struct 的页面置换环境。
  - 为内存管理结构关联特定的置换环境。
  - 在 FIFO 算法中，通过 `_fifo_init_mm` 初始化链表 `pra_list_head`，存储页面换出队列。

#### **函数：`_fifo_init_mm`**

- 功能: 初始化 FIFO 环境。
  - 初始化链表 `pra_list_head` 用于管理可换出页面。
  - 将 `mm->sm_priv` 指向链表，便于页面置换逻辑访问。

------

### **2. 页面分配阶段**

#### **函数：`alloc_pages`**

- 功能: 分配指定数量的物理页面。
  - 如果空闲页面不足并且页面置换已启用（`swap_init_ok == 1`），调用 `swap_out` 替换页面以释放内存。
  - 分配成功后返回页面指针。

#### **函数：`free_pages`**

- 功能: 释放指定的页面区间。
  - 回收已分配的物理页面，将其标记为可用。

#### **函数：`pgdir_alloc_page`**

- 功能: 分配一个物理页面，并映射到页表中的指定虚拟地址。
  - 调用 `alloc_pages` 分配页面。
  - 调用 `page_insert` 将页面映射到虚拟地址。

#### **函数：`swap_map_swappable`**

- 功能: 将一个页面标记为可换出。
  - 在 FIFO 算法中，调用 `_fifo_map_swappable`，将页面加入链表末尾。
  - 更新页面状态，准备在内存不足时进行置换。

------

### **3. 页面置换阶段**

#### **函数：`swap_out`**

- 功能: 将一个或多个页面从物理内存换出到交换区。
  - 调用 `sm->swap_out_victim`（如 `_fifo_swap_out_victim`）选择换出页面。
  - 将页面写入交换区（`swapfs_write`）。
  - 更新页表项，标记页面为无效，并释放物理内存。
  - 刷新 TLB，确保页表变化生效。

#### **函数：`swap_in`**

- 功能: 将一个页面从交换区换入到物理内存。
  - 从交换区读取页面内容（`swapfs_read`）。
  - 更新页表项，重新激活页面。
  - 将换入页面映射到物理内存。

#### **函数：`_fifo_swap_out_victim`**

- 功能: 在 FIFO 算法中选择最早加入的页面作为换出受害者。
  - 从链表头部移除页面，并返回页面指针。
  - 更新链表结构，保持先进先出的特性。

#### **函数：`swapfs_write`**

- 功能: 将物理页面内容写入交换文件系统。
  - 根据页面的虚拟地址计算交换区的位置。
  - 将页面内容保存到交换文件中，以便后续换入操作时使用。

------

### **4. 页表更新阶段**

#### **函数：`page_insert`**

- 功能: 将物理页面映射到指定虚拟地址。
  - 更新页表项，记录页面权限和物理地址。
  - 如果地址已经映射到其他页面，则调用 `page_remove` 移除旧页面。

#### **函数：`page_remove`**

- 功能: 移除指定虚拟地址到物理页面的映射。
  - 释放页面并清空页表项。
  - 调用 `tlb_invalidate` 刷新 TLB 缓存。

#### **函数：`get_pte`**

- 功能: 获取虚拟地址对应的页表项指针。
  - 如果页表项不存在且 `create` 标志为真，则分配新的页表页面。
  - 返回页表项的内核虚拟地址，用于后续修改。

#### **函数：`tlb_invalidate`**

- 功能: 刷新 TLB。
  - 确保页表更新后，TLB 缓存同步。

------

### **5. 调试与验证**

#### **函数：`check_swap`**

- 功能: 验证页面置换的正确性。
  - 初始化页面置换环境，模拟虚拟地址的访问。
  - 检查页面换入换出的逻辑是否符合预期。
  - 验证物理页面是否正确释放和分配。

#### **函数：`check_content_set`**

- 功能: 初始化测试页面的内容。
  - 模拟对虚拟地址的写入，并验证页面是否正确分配。

#### **函数：`check_content_access`**

- 功能: 验证虚拟地址的访问逻辑。
  - 检查页面置换过程中，是否按照预期访问和替换页面。

#### **函数：`_fifo_check_swap`**

- 功能: 测试 FIFO 页面置换的正确性。
  - 通过多次访问虚拟地址，模拟页面置换。
  - 验证页面换入换出的顺序是否符合 FIFO 策略。

## 练习2：深入理解不同分页模式的工作原理（思考题）

### **1. `get_pte()` 函数中两段相似代码的解释**

在 `get_pte` 函数中，有两段非常相似的代码分别用于页目录和页表的分配和查找。这两段代码的结构和逻辑几乎一致，主要区别在于操作的层级（页目录级或页表级）。结合 RISC-V 的分页机制（如 `sv32`、`sv39` 和 `sv48`），可以解释这种设计的合理性。

------

#### **分页机制（sv32、sv39 和 sv48）的关键点**

1. **分页模式的层级结构**:
   - sv32: 两级页表结构，包括：
     - **页目录（Page Directory, PD）**: 第一级页表。
     - **页表（Page Table, PT）**: 第二级页表。
   - sv39: 三级页表结构，包括：
     - **页全局目录（PGD）**: 第一级页表。
     - **页中间目录（PMD）**: 第二级页表。
     - **页表（PT）**: 第三级页表。
   - sv48: 四级页表结构，进一步增加了一层：
     - **页顶级目录（PUD）**: 最顶层目录。
2. **分页模式的异同**:
   - sv32 和 sv39/sv48 的关键区别在于页表层级数量的不同。
   - **sv32** 只有两级页表，偏移量的计算到第一级和第二级即可。
   - **sv39** 和 **sv48** 需要更深的层级，每一级都负责解析一部分虚拟地址。

------

#### **两段代码的相似性解释**

1. **第一段代码**:

   ```
   pde_t *pdep1 = &pgdir[PDX1(la)];
   if (!(*pdep1 & PTE_V)) {
       struct Page *page;
       if (!create || (page = alloc_page()) == NULL) {
           return NULL;
       }
       set_page_ref(page, 1);
       uintptr_t pa = page2pa(page);
       memset(KADDR(pa), 0, PGSIZE);
       *pdep1 = pte_create(page2ppn(page), PTE_U | PTE_V);
   }
   ```

   - **功能**: 查找或创建虚拟地址在页目录中的条目。如果条目不存在且 `create` 为 `true`，分配新的页表。
   - 对应分页层级:
     - sv32: 页目录。
     - sv39/sv48: 顶层页表（如 PGD）。

2. **第二段代码**:

   ```
   pde_t *pdep0 = &((pde_t *)KADDR(PDE_ADDR(*pdep1)))[PDX0(la)];
   if (!(*pdep0 & PTE_V)) {
       struct Page *page;
       if (!create || (page = alloc_page()) == NULL) {
           return NULL;
       }
       set_page_ref(page, 1);
       uintptr_t pa = page2pa(page);
       memset(KADDR(pa), 0, PGSIZE);
       *pdep0 = pte_create(page2ppn(page), PTE_U | PTE_V);
   }
   ```

   - **功能**: 查找或创建虚拟地址在页表中的条目。如果条目不存在且 `create` 为 `true`，分配新的页面。
   - 对应分页层级:
     - sv32: 页表。
     - sv39/sv48: 更深的中间页表（如 PMD 或 PT）。

3. **为何如此相似**:

   - RISC-V 分页机制是分层的，每一层的逻辑都是通过解析虚拟地址的一部分来找到或分配下一级页表。因此，逻辑上每层的操作几乎一致，只是作用的页表级别和解析的地址部分不同。

### **2. `get_pte` 函数设计是否需要拆分功能**

#### **当前写法的优点**

- **紧凑性**: 将页表项查找和分配功能整合在一起，代码简洁，调用方便。
- **减少代码冗余**: 避免多次调用独立的分配函数。
- **分页机制抽象一致性**: 对用户透明，用户只需调用 `get_pte`，无需关注分页层级的具体实现。

#### **拆分功能的优点**

- 单一职责原则: 按功能拆分可以提高代码的可维护性和可读性。
  - 例如，可以有 `lookup_pte` 用于查找现有条目，`create_pte` 用于分配新的条目。
- **性能优化**: 在仅需要查找而非创建时，可以避免不必要的分配逻辑。

#### **拆分后的代码设计**

1. **查找页表项（`lookup_pte`）**:

   - 仅负责查找虚拟地址对应的页表项，如果不存在则返回 `NULL`。

   ```
   pte_t *lookup_pte(pde_t *pgdir, uintptr_t la) {
       pde_t *pdep1 = &pgdir[PDX1(la)];
       if (!(*pdep1 & PTE_V)) {
           return NULL;
       }
       pde_t *pdep0 = &((pde_t *)KADDR(PDE_ADDR(*pdep1)))[PDX0(la)];
       if (!(*pdep0 & PTE_V)) {
           return NULL;
       }
       return &((pte_t *)KADDR(PDE_ADDR(*pdep0)))[PTX(la)];
   }
   ```

2. **创建页表项（`create_pte`）**:

   - 仅负责分配新的页表项，并初始化其内容。

   ```
   pte_t *create_pte(pde_t *pgdir, uintptr_t la) {
       pde_t *pdep1 = &pgdir[PDX1(la)];
       if (!(*pdep1 & PTE_V)) {
           struct Page *page = alloc_page();
           if (page == NULL) {
               return NULL;
           }
           set_page_ref(page, 1);
           uintptr_t pa = page2pa(page);
           memset(KADDR(pa), 0, PGSIZE);
           *pdep1 = pte_create(page2ppn(page), PTE_U | PTE_V);
       }
       pde_t *pdep0 = &((pde_t *)KADDR(PDE_ADDR(*pdep1)))[PDX0(la)];
       if (!(*pdep0 & PTE_V)) {
           struct Page *page = alloc_page();
           if (page == NULL) {
               return NULL;
           }
           set_page_ref(page, 1);
           uintptr_t pa = page2pa(page);
           memset(KADDR(pa), 0, PGSIZE);
           *pdep0 = pte_create(page2ppn(page), PTE_U | PTE_V);
       }
       return &((pte_t *)KADDR(PDE_ADDR(*pdep0)))[PTX(la)];
   }
   ```

3. **使用拆分函数**:

   - 查找和创建分离后，调用代码更清晰：

     ```
     pte_t *ptep = lookup_pte(pgdir, la);
     if (ptep == NULL) {
         ptep = create_pte(pgdir, la);
     }
     ```

------

### **3. 是否有必要拆分？**

#### **适合当前实现的场景**

- 如果代码中绝大多数情况下既需要查找又需要分配，当前写法更简单直接，无需拆分。

#### **适合拆分的场景**

- 如果某些场景仅需要查找，不需要分配，拆分有助于减少额外的逻辑和资源消耗。
- 如果有多种分页模式或额外的复杂逻辑（如支持多级分页架构的动态调整），拆分可以提高代码的灵活性和可维护性。

## 练习3：给未被映射的地址映射上物理页（需要编程）

### **1. 页目录项（PDE）和页表项（PTE）在页面置换中的作用**

在操作系统的分页机制中，PDE 和 PTE 分别承担了虚拟地址到物理地址映射的不同层级：

#### **(1) 页目录项（PDE）**

- 作用：
  - PDE 指向页表（Page Table）的物理地址，提供虚拟地址到具体页表的映射。
  - PDE 用于定位虚拟地址所属的页表，进一步查询具体的页面映射关系。
  - 如果 PDE 不存在（`PTE_V == 0`），需要分配新的页表并建立映射。
- 与页面置换的关系：
  - PDE 记录了页表的存在与否，以及其在物理内存中的位置。
  - 在页面置换中，如果缺页异常是由于对应的页表不存在，需通过 PDE 创建新的页表。

#### **(2) 页表项（PTE）**

- 作用：
  - PTE 直接指向页面的物理地址，记录页面的权限信息（如可写、用户模式等）。
  - 当发生缺页异常时，系统根据 PTE 的内容判断是未映射页面还是换出的页面。
- 与页面置换的关系：
  - 如果 PTE 是有效的（`PTE_V == 1`），表示页面已在物理内存中。
  - 如果 PTE 是无效的（`PTE_V == 0`），但包含交换区的地址信息，则表示页面已被换出，需要从交换区换入。

------

### **2. 缺页异常处理（硬件的工作）**

当缺页异常发生时，硬件会：

1. **保存异常地址**：
   - 将发生缺页的地址（线性地址）存储到寄存器（如 RISC-V 的 `scause` 和 `stval`）。
   - 这个地址对应的是 `do_pgfault` 中的 `addr` 参数。
2. **提供错误码**：
   - 提供异常的错误码（如 error_code），用于区分不同的异常类型：
     - **P**（Present）: 是否由于页面不存在（0）引发的异常。
     - **W/R**: 是写操作（1）还是读操作（0）。
     - **U/S**: 是用户模式（1）还是内核模式（0）。
3. **触发异常处理程序**：
   - 调用缺页处理函数 `do_pgfault`。

### **3. 数据结构中的 Page 和 PTE 关系**

- Page：
  - `Page` 结构描述了物理页面的元信息，包括引用计数、地址、是否可换出等。
  - 它是对物理内存的抽象，便于管理页面的生命周期。
- PTE：
  - `PTE` 是页表中的一个条目，直接记录页面的物理地址。
  - `PTE` 和 `Page` 的关系：
    - `Page` 的物理地址存储在 `PTE` 中。
    - `PTE` 是虚拟地址到 `Page` 的映射桥梁。

## 练习4：补充完成Clock页替换算法（需要编程）

### **Clock 和 FIFO 页替换算法的区别**

#### **1. 算法机制**

- FIFO:
  - 完全按照页面到达的顺序进行替换。
  - 无法考虑页面的使用频率，容易出现 **Belady's Anomaly**。
- Clock:
  - 在 FIFO 的基础上引入访问位，通过跳过最近访问的页面来减少频繁使用页面被替换的概率。
  - 更加智能，避免了一些不必要的替换操作。

#### **2. 数据结构**

- FIFO:
  - 只需要一个简单的队列。
- Clock:
  - 环形队列加一个指针 `curr_ptr`，用于模拟时钟。

#### **3. 优缺点**

- **FIFO 优点**: 实现简单，开销小。
- **FIFO 缺点**: 无法区分页面的访问频率，性能较差。
- **Clock 优点**: 引入访问位，能够避免频繁使用页面被替换。
- **Clock 缺点**: 需要维护访问位和环形队列，复杂度稍高。

## 练习5：阅读代码和实现手册，理解页表映射方式相关知识（思考题）

### **采用"大页"的页表映射方式的分析**

#### **1. 什么是 "大页" 页表映射？**

- 在分页机制中，“大页”是一种使用较大的页面大小（如 2MB 或 1GB 而不是传统的 4KB）进行内存管理的方式。
- 大页可以直接映射更大的内存区域，减少页表的层级和数量。

------

### **2. 优势**

1. **减少页表层级**：
   - 大页覆盖的地址范围更大，能够减少页表项的数量，从而减少页表层级。
   - 例如，传统的 4KB 页表需要三级或四级映射，而 1GB 的大页可能只需要一级。
2. **降低页表开销**：
   - 减少页表项的数量意味着更少的内存空间用于存储页表。
   - 这对于需要大规模地址映射的场景（如数据库或虚拟机管理）非常有用。
3. **提高 TLB（Translation Lookaside Buffer）效率**：
   - TLB 的每项条目通常对应一个页面的映射，使用大页可以减少 TLB 缺失（TLB Miss），从而提高地址转换的效率。
4. **更适合大块连续内存**：
   - 如果应用程序分配和访问的是大块连续的内存区域，大页能够显著减少页表项和访问开销。

------

### **3. 缺点**

1. **内存浪费**：
   - **碎片化问题**：对于小内存分配，如果使用大页，未使用的内存区域会被浪费。
   - 例如，一个进程只需要 3KB 的内存，但分配了一个 2MB 的大页，浪费了大部分空间。
2. **灵活性降低**：
   - 小页可以更精细地映射虚拟内存和物理内存，而大页则缺乏这种灵活性。
   - 例如，对于非连续的内存分配，大页可能难以高效地利用内存。
3. **适配复杂性**：
   - 操作系统需要额外的逻辑来支持混合页表映射（即同时支持大页和小页）。
   - 页表管理变得更加复杂，尤其是在支持不同大小的页面时。
4. **不适合小块内存访问**：
   - 如果应用程序主要进行小块的内存访问，大页可能不适合，因为它会占用过多的内存。

------

### **4. 风险**

1. **安全隐患**：
   - 大页会映射较大的内存区域，一旦发生越界访问或内存漏洞，可能会影响整个大页范围的内存，扩大漏洞的影响范围。
2. **页表缓存污染**：
   - 如果大页的某些部分频繁访问，而其他部分不被使用，会导致 TLB 的缓存条目被浪费，从而降低 TLB 的利用率。
3. **碎片化问题的加剧**：
   - 在物理内存不足时，分配大页可能失败，而分配小页却可以成功。
   - 如果操作系统频繁分配大页，会导致内存碎片化更加严重。

------

### **5. 适用场景**

1. **适合场景**：
   - 大型数据处理应用（如数据库、科学计算、图像处理）。
   - 虚拟机管理（如 Hypervisor），需要大规模地址映射。
   - 需要高性能的内存访问场景。
2. **不适合场景**：
   - 小型应用程序或需要分配大量小块内存的程序。
   - 高度动态且频繁更改地址映射的场景。

### **总结**

| **维度**       | **大页**                           | **小页**                     |
| -------------- | ---------------------------------- | ---------------------------- |
| **内存效率**   | 大块连续内存效率高，小内存浪费多   | 更适合小块内存分配，利用率高 |
| **性能**       | 提高 TLB 命中率，性能更高          | 性能较低，易出现 TLB Miss    |
| **灵活性**     | 灵活性差，不适合动态小块内存分配   | 灵活性高，适合精细化内存管理 |
| **实现复杂性** | 页表实现较复杂，适合大规模内存场景 | 页表简单，适合小规模内存场景 |
| **安全性**     | 较大内存区域的越界访问风险较高     | 越界影响范围小，相对安全     |

## 扩展练习 Challenge：实现不考虑实现开销和效率的LRU页替换算法（需要编程）

- 详细见设计文档