### 练习

对实验报告的要求：

- 基于markdown格式来完成，以文本方式为主

- 填写各个基本练习中要求完成的报告内容

- 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别

- 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）

- 列出你认为OS原理中很重要，但在实验中没有对应上的知识点


#### 练习0：填写已有实验

本实验依赖实验1。请把你做的实验1的代码填入本实验中代码中有“LAB1”的注释相应部分并按照实验手册进行进一步的修改。具体来说，就是跟着实验手册的教程一步步做，然后完成教程后继续完成完成exercise部分的剩余练习。

已完成

#### 练习1：理解first-fit 连续物理内存分配算法（思考题）

first-fit 连续物理内存分配算法作为物理内存分配一个很基础的方法，需要同学们理解它的实现过程。请大家仔细阅读实验手册的教程并结合`kern/mm/default_pmm.c`中的相关代码，认真分析default_init，default_init_memmap，default_alloc_pages， default_free_pages等相关函数，并描述程序在进行物理内存分配的过程以及各个函数的作用。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：

- 你的first fit算法是否有进一步的改进空间？

##### 设计实现过程

程序在内存管理的过程中，首先在`kern_init()`函数中调用`pmm_init()`来初始化物理内存管理器，并设置虚拟内存的映射。在`pmm_init()`中会依次调用`init_pmm_manager()`和`page_init()`。

- `init_pmm_manager()`负责设置物理内存管理器并初始化。
- `page_init()`负责检测物理内存的状态，将空闲内存划分成页，创建Page结构体，计算空闲内存的起始地址和可用页面的数量，最终调用`init_memmap()`来完成管理器的初始化。

##### Page结构体

内存管理中使用的页结构体`Page`包括以下字段：
- `ref`：记录该页被引用的次数，当有虚拟页映射到此物理页时，引用计数增加，取消映射时则减少。
- `flags`：包含一些标志位，用于描述该页的状态，例如`PG_reserved`表示页是否被内核占用，`PG_property`表示该页是否为空闲块的起始页。
- `property`：当该页为空闲块的起始页时，记录该块中连续空闲页的数量。
- `page_link`：用于将多个连续空闲块链接在一起，形成双向链表，以便进行内存分配和释放。

##### first-fit算法的函数实现

first-fit算法使用双向链表`free_list`记录空闲块，并使用`nr_free`记录空闲页面的总数。主要实现的函数包括：

- `default_init_memmap(struct Page *base, size_t n)`：接收空闲页面的起始地址`base`和数量`n`，初始化这些页面的属性，将它们视为一个大块空闲块加入空闲链表。

- `default_alloc_pages(size_t n)`：按照地址从小到大的顺序查找满足需求的空闲块，从链表头开始寻找第一个符合要求的块，然后将其从空闲链表中移除。如果分配后的空闲块有剩余，则将剩余部分作为新的空闲块插入到原位置，保持链表的顺序。

- `default_free_pages(struct Page *base, size_t n)`：遍历并将释放的页面属性设置为空闲状态，更新起始页的`property`值和空闲页总数。然后检查前后相邻页面是否为空闲状态，如果是，则合并这些页面，并更新对应的`property`值，最后从链表中移除不再需要的页面。

##### 改进空间

- 目前first-fit算法在查找空闲块时效率较低，因为需要遍历整个链表，可以考虑使用更高效的数据结构（如哈希表）来加速查找。
- 合并相邻的空闲块可以减少内存碎片，提高内存的利用率。

#### 练习2：实现 Best-Fit 连续物理内存分配算法（需要编程）
在完成练习一后，参考kern/mm/default_pmm.c对First Fit算法的实现，编程实现Best Fit页面分配算法，算法的时空复杂度不做要求，能通过测试即可。
请在实验报告中简要说明你的设计实现过程，阐述代码是如何对物理内存进行分配和释放，并回答如下问题：
- 你的 Best-Fit 算法是否有进一步的改进空间？

#### 扩展练习Challenge：buddy system（伙伴系统）分配算法（需要编程）

Buddy System算法把系统中的可用存储空间划分为存储块(Block)来进行管理, 每个存储块的大小必须是2的n次幂(Pow(2, n)), 即1, 2, 4, 8, 16, 32, 64, 128...

 -  参考[伙伴分配器的一个极简实现](http://coolshell.cn/articles/10427.html)， 在ucore中实现buddy system分配算法，要求有比较充分的测试用例说明实现的正确性，需要有设计文档。
 
#### 扩展练习Challenge：任意大小的内存单元slub分配算法（需要编程）

slub算法，实现两层架构的高效内存单元分配，第一层是基于页大小的内存分配，第二层是在第一层基础上实现基于任意大小的内存分配。可简化实现，能够体现其主体思想即可。

 - 参考[linux的slub分配算法/](http://www.ibm.com/developerworks/cn/linux/l-cn-slub/)，在ucore中实现slub分配算法。要求有比较充分的测试用例说明实现的正确性，需要有设计文档。

#### 扩展练习Challenge：硬件的可用物理内存范围的获取方法（思考题）
  - 如果 OS 无法提前知道当前硬件的可用物理内存范围，请问你有何办法让 OS 获取可用物理内存范围？


> Challenges是选做，完成Challenge的同学可单独提交Challenge。完成得好的同学可获得最终考试成绩的加分。